---
layout: post
title: Milestone 1
toc: true
---

## Question 1

## Question 2 : Outil de débogage interactif

Ceci est un apercu de l'outil de débogage interactif:

![Apercu de l'outil de débogage](/public/debugging-tool.png)

Le code pour l'implementer est le suivant:

  ```python

import ipywidgets
import pprint
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from src.fetch.NHLData import NHLData

def plot_nhl_data(nhl_data_provider: NHLData, game_type, season):
    if (game_type == 'regular'):
        games_data = nhl_data_provider.regular_season[season]
    else:
        games_data = nhl_data_provider.playoffs[season]

    game_count = len(games_data)
    ipywidgets.interact(plot_game, game_number=(1, game_count, 1), games_data=ipywidgets.fixed(games_data))


def plot_game(game_number, games_data):
    game_data = games_data[game_number - 1]

    print(game_data['startTimeUTC'])
    print(
        f"Game ID: {game_number}; {game_data['homeTeam']['abbrev']} (home) vs {game_data['awayTeam']['abbrev']} (away)")

    col1 = ['', 'Teams', 'Goals', 'SoG']
    col2 = ["Home", f"{game_data['homeTeam']['abbrev']}", f"{game_data['homeTeam']['score']}",
            f"{game_data['homeTeam']['sog']}"]
    col3 = ["Away", f"{game_data['awayTeam']['abbrev']}", f"{game_data['awayTeam']['score']}",
            f"{game_data['awayTeam']['sog']}"]
    print('')
    for c1, c2, c3 in zip(col1, col2, col3):
        print(f'{c1:<18} {c2:<18} {c3:<18}')

    event_count = len(game_data['plays'])

    ipywidgets.interact(plot_game_event, event_number=(1, event_count, 1), game_data=ipywidgets.fixed(game_data))


def plot_game_event(game_data, event_number):
    event_data = game_data['plays'][event_number - 1]
    print("infos de l'evenement")

    img = mpimg.imread('images/patinoire.png')
    img_height, img_width = img.shape[0], img.shape[1]

    fig, ax = plt.subplots()

    # Afficher l'image dans le fond
    ax.imshow(img, extent=[-100, 100, -42.5, 42.5], origin='lower')

    # Positionner les axes x et y aux bords (gauche pour y et bas pour x)
    ax.spines['left'].set_position(('axes', 0))  # Garder l'axe y à gauche
    ax.spines['bottom'].set_position(('axes', 0))  # Garder l'axe x en bas

    # Masquer les axes du haut et de droite
    ax.spines['right'].set_color('none')
    ax.spines['top'].set_color('none')

    if ('details' in event_data and 'xCoord' in event_data['details'] and 'yCoord' in event_data['details']):
        ax.scatter(event_data['details']['xCoord'], event_data['details']['yCoord'], color="blue", s=100, zorder=5)

    y_min, y_max = plt.ylim()

    if event_data['homeTeamDefendingSide'] == 'right':
        home_team_position_x = 40
        away_team_position_x = -60
    else:
        home_team_position_x = -60
        away_team_position_x = 40

    plt.text(home_team_position_x, y_max, game_data['homeTeam']['abbrev'], fontsize=12, verticalalignment='bottom')
    plt.text(away_team_position_x, y_max, game_data['awayTeam']['abbrev'], fontsize=12, verticalalignment='bottom')

    plt.show()

    # on affiche les données brute de l'évenement
    pprint.pprint(event_data)

  ```

Avec cet outil, on peut sélectionner une saison, le type de match (saison régulière ou séries éliminatoires)
et obtenir les informations brutes (telles que récupérées sur site du NHL) sur les matchs correspondant aux critères. On peut
également visualiser les données des évenements qui se sont produits durant un match.

## Question 3 : Nettoyer les données

Le nettoyage des données consiste à préparer les données brutes pour les rendre exploitables.
Dans ce contexte, cela implique la gestion des événements de jeu (tir et but), l'extraction d'informations, la création de nouvelles caractéristiques...

Voici un aperçu de la 124ᵉ partie de NHL en saison régulière pour l'année 2022 :

|  | idGame | periodType | currentPeriod | timeInPeriod | eventOwnerTeam | homeTeamDefendingSide | typeDescKey | iceCoord |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 0 | 2022020124 | REG | 1/3 | 2022-10-28 23:02:45+00:00 | Islanders | right | shot-on-goal | \(34, 31\) |
| 1 | 2022020124 | REG | 1/3 | 2022-10-28 23:03:42+00:00 | Islanders | right | shot-on-goal | \(78, -16\) |
| 2 | 2022020124 | REG | 1/3 | 2022-10-28 23:04:53+00:00 | Hurricanes | right | shot-on-goal | \(-45, 34\) |
| 3 | 2022020124 | REG | 1/3 | 2022-10-28 23:04:57+00:00 | Hurricanes | right | shot-on-goal | \(-74, 7\) |
| 4 | 2022020124 | REG | 1/3 | 2022-10-28 23:07:30+00:00 | Hurricanes | right | shot-on-goal | \(-13, -30\) |


| shootingPlayer      | goaliePlayer | shotType | teamSide | emptyGoalNet | isGoalAdvantage | shotDistance | shotAngle | timeSinceLastShot |
|:--------------------| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| Sebastian Aho       | Frederik Andersen | slap | away | False | Neutral | 63.1 | 42.357455 | 0:00 |
| Jean-Gabriel Pageau | Frederik Andersen | deflected | away | False | Neutral | 19.4 | 11.592175 | 0:57 |
| Brett Pesce         | Ilya Sorokin | slap | home | False | Neutral | 55.6 | 37.073073 | 0:00 |
| Jesper Fast         | Ilya Sorokin | wrist | home | False | Neutral | 16.6 | 5.403791 | 0:04 |
|  Andrei Svechnikov  | Ilya Sorokin | wrist | home | False | Neutral | 81.7 | 66.571307 | 2:33 |


Tout commence par la fonction `clean_data`, qui est responsable du nettoyage et de l’organisation des données brutes issues de l'API. Les données sont séparées en deux catégories : la saison régulière et les séries éliminatoires.
Pour chaque catégorie, cette fonction va parcourir les années disponibles, nettoyer les données pour chaque match et les structurer.

La deuxième fonction principale `convert_game_to_dataframe` est le cœur du processus de nettoyage.
Pour chaque match d'une saison, elle transforme les données brutes en un dataframe nettoyé. Ce processus se déroule en plusieurs étapes.
On commence par sélectionner les différentes informations du JSON (statistiques de jeu, les joueurs, les équipes).
On filtre pour ne garder que les informations essentielles puis on traite chacune des parties pour améliorer la pertinence des données.
Enfin, on ajoute plusieurs caractéristiques venant enrichir notre dataframe final.

Tout ceci va être segmenté dans différentes fonctions :

Une fois les données en dataframe, on s’occupe du temps de jeu. L’un des défis de l’analyse des matchs est de bien comprendre quand chaque événement s’est produit.
Pour cela, on convertit le temps pour avoir une mesure précise du jour et de l'heure du match puis l'on ajoute la période sur laquelle se joue l'action.
Ensuite, on ne garde que les événements les plus pertinents pour l’analyse, à savoir les tirs et les buts.

On s'intéresse maintenant aux détails de chaque événement.
Par exemple, on ajoute les coordonnées sur la glace pour savoir d’où le tir a été effectué, et on associe les joueurs à chaque action.
C’est à cette étape que des éléments supplémentaires sont ajoutés aux événements, comme le nom du joueur qui a tiré et le gardien qui a fait face au tir...
L’objectif ici est de bien comprendre ce qui s’est passé sur la glace.

Une fois que les données de base sont nettoyées et développées, plusieurs colonnes supplémentaires sont ajoutées :

- **Filet vide** : L’une des informations cruciales en hockey est de savoir si un but a été marqué lorsque le filet adverse était vide.
- **Avantage numérique** : si l'équipe qui fait l'action est en avantage ou en désavantage numérique en fonction de sa composition sur la glace.

#### Création de nouvelles fonctionnalités avec `additional_features` :

- **Distance du tir** : La distance entre la position du joueur et le but est calculée.
- **Angle du tir** : En plus de la distance, l'angle sous lequel le tir a été effectué est calculé.
- **Temps depuis le dernier tir** : Pour mesurer la pression offensive d’une équipe, le temps écoulé depuis le dernier tir est calculé.

Une fois toutes ces étapes terminées, la fonction retourne deux ensembles de données (pour la saison régulière et pour les séries éliminatoires).

À travers ce processus de nettoyage, les données brutes issues de l'API NHL sont transformées en un ensemble de données riche et prêt à être exploité.
Chaque étape, jusqu'à l'ajout de nouvelles features, permet de mieux comprendre les données que nous manipulons et d'analyser les matchs de hockey.
